-- NULL With COALESCE --
true = true (Output: true)
false = false (Output: true)
null = null (Output: false)
null != null (Output: false)

========== We need to use null like this ==========
SELECT * FROM students WHERE email is null;
SELECT * FROM students WHERE email is not null;

-- COALESCE (Returns the first "not null" value) --
SELECT coalesce(null, null, 3, 2);  --> Output: 3 (Because it's the first not null)

SELECT first_name, last_name, coalesce(email, 'Not provided') 
FROM students;  --> (If someone don't give email it will show "Not provided");

-- LIMIT --
SELECT * FROM students LIMIT 5;
SELECT * FROM students WHERE grade = 'A+' LIMIT 5;
SELECT * FROM students LIMIT 5 OFFSET 3; --> (It will show 5 but except first 3)

-- PAGINATION --
SELECT * FROM students LIMIT 5 OFFSET 5 * 0;  --> (OFFSET = 0)
SELECT * FROM students LIMIT 5 OFFSET 5 * 1;  --> (OFFSET = 5)
SELECT * FROM students LIMIT 5 OFFSET 5 * 2;  --> (OFFSET = 10)

-- UPDATE --
UPDATE students
SET email = 'defaul@gmail.com'
WHERE email IS NULL;

-- 
UPDATE students
SET
  first_name = 'Ariful',
  age = 32
WHERE student_id = 1;

--
UPDATE students
SET grade = 'C'
WHERE student_id = 1 OR student_id = 3;

-- DELETE --
DELETE FROM students
WHERE grade = 'C';

--
DELETE FROM students
WHERE grade = 'B' AND age > 20;

-- GROUP BY --
(Here we can retrieve one value for one row when we want to group by a column)

SELECT country, AVG(age)
FROM students
GROUP BY country;

// Number of students for each country //
SELECT country, count(*)
FROM students
GROUP BY country
ORDER BY count DESC;

// Count students by grade //
SELECT grade, count(*)
FROM students
GROUP BY grade;

-- GROUP BY with HAVING (Filtering) --

// Courses with more than 3 courses //
SELECT course, count(*)
FROM students
GROUP BY course
HAVING count(*) > 3;

// Countries where average student age is more than 28 //
SELECT country, AVG(age)
FROM students
GROUP BY country
HAVING AVG(age) > 28;

-----------------------------------------------------------------------------

-- FOREIGN KEY --
CREATE TABLE users (
  id serial PRIMARY KEY,
  username varchar(25) NOT NULL
);

CREATE TABLE posts (
  id serial PRIMARY KEY,
  title TEXT NOT NULL,
  user_id int REFERENCES users (id)
);

INSERT INTO
  users (username)
VALUES
  ('Sayem'),
  ('Akash'),
  ('Asif'),
  ('Srayo')

INSERT INTO
  posts (title, user_id)
VALUES
  ('This is a nice day', 2),
  ('Enjoying the raining', 1),
  ('Travelling to Comilla', 4),
  ('Great to see the result', 4)

-- JOIN --

// Inner Join //

// Get post title with the username //
SELECT title, username
FROM posts
JOIN users ON posts.user_id = users.id

// Get post title with the username (Using aliasing and avoiding ambiguity) //
SELECT p.id, title, username
FROM posts AS p
JOIN users AS u ON p.user_id = u.id;

// Left Join //
SELECT *
FROM posts AS p
LEFT JOIN users AS u ON p.user_id = u.id;

// Right Join //
SELECT *
FROM posts AS p
RIGHT JOIN users AS u ON p.user_id = u.id;

// Full Join //
SELECT *
FROM posts AS p
FULL JOIN users AS u ON p.user_id = u.id;

// Cross Join and Natural Join //

CREATE TABLE employees (emp_id int, emp_name varchar(50), dept_id int);
CREATE TABLE departments (dept_id int, dept_name varchar(30));

INSERT INTO employees VALUES (1, 'John Doe', 101);
INSERT INTO employees VALUES (2, 'Jane Smith', 102);

INSERT INTO departments VALUES (101, 'HR');
INSERT INTO departments VALUES (102, 'IT');

-- Cross Join --
SELECT *
FROM employees 
CROSS JOIN departments;

-- Natural Join --
SELECT *
FROM employees
NATURAL JOIN departments;